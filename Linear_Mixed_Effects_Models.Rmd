---
title: "Fitting Linear Mixed-Effects Models (LMMs) Using lme4 on 7476 probes"
subtitle: "Part 2: Running LMMs and Tukey's Test on Significant CpGs"
author: "Rebecca Asiimwe"
output:
  html_document: default
  pdf_document: default
editor_options:
  chunk_output_type: console
---

&nbsp;
&nbsp;

#### Running Linear Mixed-Effects Models on different tissues (1-3) from an environmental exposure dataset with 4 distinct exposures (Exposure (Exp) 1 - 4).

#### Cohort description: Concealed for purposes of this example


### Loading required libraries
```{r, warning = FALSE, message = FALSE, results = "hide"}
library(lme4)
library(dplyr)
library(magicfor)
library(Matrix)
library(parallel)
library(rlist)
library(tidyr)
library(batchtools)
library(kableExtra)
library(graphics)
library(readxl)
library(reshape)
library(ggplot2)
library(multcomp)
library(lmerTest)
library(emmeans)
library(cowplot)
library(gridExtra)
```


### LMMs run
*Model 1:* lmer(cpg ~ Sex + Exposure + DiseaseDiagnosis + AgeAtScreen + (1 | ParticipantNumber), data = data, REML=F)

*Model 2:* lmer(cpg ~ Sex + DiseaseDiagnosis + AgeAtScreen + (1 | ParticipantNumber), data = data, REML=F)

*Model 3:* lmer(cpg ~ Sex + Exposure + AgeAtScreen + (1 | ParticipantNumber), data = data, REML=F)


### Extracting *p* and *q* values for all Cohort datasets and on all 7476 identified autosomal probes

### Tissue3 LMMs
#### Tissue3:- Running Model 1 against Model 2 to establish effect of Exposure
```{r, eval=FALSE}
#Loading Tissue3 M-Values and candidates found in Tissue3
load("rasiimwe/File_Share/Analysis/LMM19/sites_Cohort/Tissue3/meta_mvals_Tissue3_clean.RData")
load("rasiimwe/File_Share/Analysis/LMM19/sites_Cohort/Tissue3/cpg_list_Tissue3.RData")

#Running lme4 and ANOVA on Model 1 & 2 - effect of exposure
magic_for(silent = TRUE) #Using magic-for to keep loop results in memory
result_Tissue3_m1_2 <- data.frame() #Creating empty object to hold ANOVA results in loop

for(x in cpg_list_Tissue3){
  #Function below allows for parallel estimation of multiple models
  f_lmer_mc = function(data, calls, mc.cores) {
  require(parallel)
  if (is.data.frame(data)) 
    data = replicate(length(calls), data, simplify = F)
  for (i in 1:length(data)) attr(data[[i]], "cll") = calls[i]
  m.list = mclapply(data, function(i) eval(parse(text = attr(i, "cll"))), 
                    mc.cores = mc.cores)
  return(m.list)
  }
  #Running model 1 against model 2 to establish effect of exposure
  m1 <- paste0("lmer(", noquote(x),  " ~ Sex + Exposure + DiseaseDiagnosis + AgeAtScreen + (1 | ParticipantNumber), data = i, REML=F)")
  m2 <- paste0("lmer(",  noquote(x),  " ~ Sex  + DiseaseDiagnosis + AgeAtScreen + (1 | ParticipantNumber), data = i, REML=F)")
  (mdls <- c(m1, m2))
  m.list = f_lmer_mc(meta_mvals_Tissue3_clean, mdls, 1) #Calling  parallelization function to run the list of models (mdls) on 1 core - preferably 2 for faster results; number of cores can be equal to number of models
  result_Tissue3_m1_2 <- do.call(anova, m.list) #Running ANOVA on models 1 and 2
  results_all_Tissue3_m1_2 <- as.data.frame(do.call(rbind, result_Tissue3_m1_2)) #rbind ANOVA results for models from each cpg being looped through
  put(results_all_Tissue3_m1_2) #put() is almost similar to the return() or print() functions but further helps to store magicalized values 
}
final_results_Tissue3_m1_2 <- magic_result_as_dataframe() #Extracting magicalized/ stored results from loop
magic_free() #Clearing stored results to avoid interference with next run
```

#### Tissue3:- Running Model 1 against Model 3 to establish effect of DiseaseDiagnosis
```{r, eval=FALSE}
#Running lme4 and ANOVA on Model 1 & 3
magic_for(silent = TRUE) #Using magic-for to keep loop results in memory
result_Tissue3 <- data.frame() #Creating empty object to hold ANOVA results in loop

for(x in cpg_list_Tissue3){
  #Function below allows for parallel estimation of multiple models
  f_lmer_mc = function(data, calls, mc.cores) {
  require(parallel)
  if (is.data.frame(data)) 
    data = replicate(length(calls), data, simplify = F)
  for (i in 1:length(data)) attr(data[[i]], "cll") = calls[i]
  m.list = mclapply(data, function(i) eval(parse(text = attr(i, "cll"))), 
                    mc.cores = mc.cores)
  return(m.list)
  }
  #Running modle 1 against model 3 to establish effect of DiseaseDiagnosis
  m1 <- paste0("lmer(", noquote(x),  " ~ Sex + Exposure + DiseaseDiagnosis + AgeAtScreen + (1 | ParticipantNumber), data = i, REML=F)")
  m3 <- paste0("lmer(", noquote(x), " ~ Sex + Exposure + AgeAtScreen + (1 | ParticipantNumber), data = i, REML=F)")
  (mdls <- c(m1, m3))
  m.list = f_lmer_mc(meta_mvals_Tissue3_clean, mdls, 1) #Calling  parallelization function to run the list of models (mdls) on 1 core - preferably 2 for faster results; number of cores can be equal to number of models
  result_Tissue3 <- do.call(anova, m.list) #Running ANOVA on models 1 & 3
  results_all_Tissue3 <- as.data.frame(do.call(rbind, result_Tissue3)) #rbind ANOVA results for models from each cpg being looped through
  put(results_all_Tissue3) #put() is almost similar to the return() or print() functions but further helps to store magicalized values#put() is almost similar to the return() or print() functions but further helps to store magicalized values
}
final_results_Tissue3_m1_3 <- magic_result_as_dataframe() #Extracting magicalized/ stored results from loop
magic_free() #Clearing stored results to avoid interference with next run

#Storing results from ANOVA call for models 1-2 and 1-3
save(final_results_Tissue3_m1_2, file="rasiimwe/File_Share/Analysis/LMM19/sites_Cohort/Tissue3/final_results_Tissue3_m1_2_call3.RData")
save(final_results_Tissue3_m1_3, file="rasiimwe/File_Share/Analysis/LMM19/sites_Cohort/Tissue3/final_results_Tissue3_m1_3_call3.RData")
```


#### Tissue3:- extracting *p-values* from the ANOVA summary tables and converting *p* to *q-values* (Model 1 & 2 - establishing effect of exposure)
```{r}
#Mapability object with gene names
load("shared_coding_resource/Gene_CpG_Relations_updatejune2015.RData")
Genes <- Gene_CpG_Relations_update
SARS_CoV_2_candidates <- read.csv("rasiimwe/File_Share/Analysis/LMM19/Lieberman_SARS-CoV-2_sex.csv")
Dat <- Genes[which(Genes$gene %in% SARS_CoV_2_candidates$Genes),]
dim(cpgs <- Dat[!duplicated(Dat$Probe_ID), ]) #343 probes in total

colnames(cpgs)[c(1,4)] <- c("CpG", "Gene")
gene_name_mapping <- cpgs[,c(1, 4)]

#Loading results from the anavo call on model 1 and 2 
load("rasiimwe/File_Share/Analysis/LMM19/sites_Cohort/Tissue3/final_results_Tissue3_m1_2_call3.RData")
head(final_results_Tissue3_m1_2, n = 5)

#Unnesting dataframe
final_results_unnested_Tissue3_m1_2 <- as.data.frame(unnest(final_results_Tissue3_m1_2, cols = c(results_all_Tissue3_m1_2)))
colnames(final_results_unnested_Tissue3_m1_2) <- c("CpG", "model2", "model1") #The p-value from running ANOVA on model 1 and 2 is stored in the model1 variable 
head(final_results_unnested_Tissue3_m1_2, n = 5)

#Extracting p-values from models 1 and 2 
final_results_unnested_Tissue3_sig_m1_2 <- final_results_unnested_Tissue3_m1_2[seq(8, nrow(final_results_unnested_Tissue3_m1_2), 8), ] #p-values are at every 8th row, extracting only p-values
final_results_unnested_Tissue3_sig_m1_2$model2 <- NULL
colnames(final_results_unnested_Tissue3_sig_m1_2) <- c("CpG", "P_Value") 

final_results_unnested_Tissue3_sig_m1_2 %>% head(n = 10) %>% 
  kable(caption = "Tissue3-Exposure: Dataset with p-values from model1 - model2 comparisons (ANOVA)") %>% 
  kable_styling(c("striped", "bordered"),
                full_width = FALSE) 

#Table of p-values < 0.01
pvalue_0.01 <- final_results_unnested_Tissue3_sig_m1_2 %>% 
  filter(final_results_unnested_Tissue3_sig_m1_2$P_Value < 0.01)
pvalue_0.01 <- inner_join(pvalue_0.01, gene_name_mapping, by = "CpG")
colnames(pvalue_0.01) <- c("CpG", "P_Value_0.01", "Gene") 

nrow(pvalue_0.01)

pvalue_0.01 %>% head(n = 10) %>% 
  kable(caption = "3 CpGs in total with p-value < 0.01 (Tissue3-Exposure)") %>% 
  kable_styling(c("striped", "bordered"),
                full_width = FALSE) 

#Converting p to q-values 
#Test run on all p.adjust.methods to see which performs best converting our p to q values
p_values <- final_results_unnested_Tissue3_sig_m1_2$P_Value

p.adjust.M <- p.adjust.methods[p.adjust.methods != "BH"]
p.adj    <- sapply(p.adjust.M, function(meth) p.adjust(p_values, meth))
stopifnot(identical(p.adj[,"none"], p_values), p.adj <= p.adj)
Tissue3_exposure_fdr <- as.data.frame(round(p.adj, 3))

#Table of q-values from all methods
Tissue3_exposure_fdr %>% head(n = 10) %>% 
  kable(caption = "Table of q-values from all p.adjust.methods (Tissue3-Exposure)") %>% 
  kable_styling(c("striped", "bordered"),
                full_width = FALSE) 

#Extracting minimum q-value from each model 
min(Tissue3_exposure_fdr$holm)
min(Tissue3_exposure_fdr$hochberg)
min(Tissue3_exposure_fdr$hommel)
min(Tissue3_exposure_fdr$bonferroni)
min(Tissue3_exposure_fdr$BY)
min(Tissue3_exposure_fdr$fdr)
#As seen above, none of the p.adjust.methods gives us q-values <= 0.10

#Plot methods
#matplot(p_values, p.adj, ylab="p.adjust(data, method)", type = "l", asp = 1, lty = 1:6,
 #       main = "P-value adjustments")
#legend(0.7, 0.6, p.adjust.M, col = 1:6, lty = 1:6)

#Converting p-values to q-values
final_results_unnested_Tissue3_sig_m1_2$Q_Value_0.10 <-  round(p.adjust(final_results_unnested_Tissue3_sig_m1_2$P_Value, "fdr"), 2)
dim(Tissue3_exposure <- final_results_unnested_Tissue3_sig_m1_2 %>% 
      filter(Q_Value_0.10 <= 0.10)) #No CpGs meeting FDR <= 0.10

#Candidates meeting FDR <= 0.10 in Tissue3 - Exposure
Tissue3_exposure <- inner_join(Tissue3_exposure, gene_name_mapping, by = "CpG")
Tissue3_exposure %>% 
  kable(caption = "Candidates meeting FDR <= 0.10 in Tissue3 (Effect of Exposure): (n = 0)") %>% 
  kable_styling(c("striped", "bordered"),
                full_width = FALSE) 
```

#### Tissue3:- extracting *p-values* from the ANOVA summary tables and converting *p* to *q-values* (Model 1 & 3 - establishing effect of DiseaseDiagnosis)
```{r}
#Loading results from the anavo call on model 1 and 3 
load("rasiimwe/File_Share/Analysis/LMM19/sites_Cohort/Tissue3/final_results_Tissue3_m1_3_call3.RData")
head(final_results_Tissue3_m1_3, n = 5)

#Unnesting dataframe
final_results_unnested_Tissue31_3 <- as.data.frame(unnest(final_results_Tissue3_m1_3, cols = c(results_all_Tissue3)))
colnames(final_results_unnested_Tissue31_3) <- c("CpG", "model2", "model1") #The p-value from running ANOVA on model 1 and 3 is stored in the model1 variable 
head(final_results_unnested_Tissue31_3, n = 5)

#Extracting p-values from models 1 and 3
final_results_unnested_Tissue3_sig_m1_3 <- final_results_unnested_Tissue31_3[seq(8, nrow(final_results_unnested_Tissue31_3), 8), ] #pvalues are at every 8th row, extracting only pvalues 
final_results_unnested_Tissue3_sig_m1_3$model2 <- NULL
colnames(final_results_unnested_Tissue3_sig_m1_3) <- c("CpG", "P_Value")

final_results_unnested_Tissue3_sig_m1_3 %>% head(n = 10) %>%   
  kable(caption = "Tissue3-DiseaseDiagnosis: Dataset with p-values from model1 - model3 comparisons (ANOVA)") %>% 
  kable_styling(c("striped", "bordered"),
                full_width = FALSE) 

#Table of p-values < 0.01
pvalue_0.01 <- final_results_unnested_Tissue3_sig_m1_3 %>% 
  filter(final_results_unnested_Tissue3_sig_m1_3$P_Value < 0.01)
pvalue_0.01 <- inner_join(pvalue_0.01, gene_name_mapping, by = "CpG")
colnames(pvalue_0.01) <- c("CpG", "P_Value_0.01", "Gene") 

nrow(pvalue_0.01)

pvalue_0.01 %>% 
  head(n = 10) %>% 
  kable(caption = "0 CpGs in total with p-value < 0.01 (Tissue3-DiseaseDiagnosis)") %>% 
  kable_styling(c("striped", "bordered"),
                full_width = FALSE) 

#Converting p to q-values 
#Test run on all p.adjust.methods to see which performs best converting our p to q values
p_values <- final_results_unnested_Tissue3_sig_m1_3$P_Value

p.adjust.M <- p.adjust.methods[p.adjust.methods != "BH"]
p.adj    <- sapply(p.adjust.M, function(meth) p.adjust(p_values, meth))
stopifnot(identical(p.adj[,"none"], p_values), p.adj <= p.adj)
Tissue3_Disease_fdr <- as.data.frame(round(p.adj, 3))

#Table of q-values from all methods
Tissue3_Disease_fdr %>% head(n = 10) %>% 
  kable(caption = "Table of q-values from all p.adjust.methods (Tissue3-DiseaseDiagnosis)") %>% 
  kable_styling(c("striped", "bordered"),
                full_width = FALSE) 

#Extracting minimum q-value from each model 
min(Tissue3_Disease_fdr$holm)
min(Tissue3_Disease_fdr$hochberg)
min(Tissue3_Disease_fdr$hommel)
min(Tissue3_Disease_fdr$bonferroni)
min(Tissue3_Disease_fdr$BY)
min(Tissue3_Disease_fdr$fdr)
#As seen above, none of the p.adjust.methods gives us q-values <= 0.10

#Converting p-values to q-values
final_results_unnested_Tissue3_sig_m1_3$Q_Value_0.10 <- round(p.adjust(final_results_unnested_Tissue3_sig_m1_3$P_Value, "fdr"), 2)
dim(Tissue3_Disease <- final_results_unnested_Tissue3_sig_m1_3 %>% 
      filter(Q_Value_0.10 <= 0.10)) #No CpGs meeting FDR <= 0.10

#Candidates meeting FDR <= 0.10 in Tissue3 - Disease
Tissue3_Disease <- inner_join(Tissue3_Disease, gene_name_mapping, by = "CpG")
Tissue3_Disease %>% 
  kable(caption = "Candidates meeting FDR <= 0.10 in Tissue3 (Effect of DiseaseDiagnosis): (n = 0)") %>% 
  kable_styling(c("striped", "bordered"),
                full_width = FALSE) 
```

### Tissue1 LMMs
#### Tissue1:- Running Model 1 against Model 2 to establish effect of Exposure
```{r, eval=FALSE}
#Loading Tissue1 M-Values and candidates found in Tissue1
load("rasiimwe/File_Share/Analysis/LMM19/sites_Cohort/Tissue1/meta_mvals_Tissue1_clean.RData")
load("rasiimwe/File_Share/Analysis/LMM19/sites_Cohort/Tissue1/cpg_list_Tissue1.RData")

#Running lme4 and ANOVA on Model 1 & 2 - effect of exposure
magic_for(silent = TRUE) #Using magic-for to keep loop results in memory
result_Tissue1_1_2 <- data.frame() #Creating empty object to hold ANOVA results in loop

for(x in cpg_list_Tissue1){
  #Function below allows for parallel estimation of multiple models
  f_lmer_mc = function(data, calls, mc.cores) {
    require(parallel)
    if (is.data.frame(data)) 
      data = replicate(length(calls), data, simplify = F)
    for (i in 1:length(data)) attr(data[[i]], "cll") = calls[i]
    m.list = mclapply(data, function(i) eval(parse(text = attr(i, "cll"))), 
                      mc.cores = mc.cores)
    return(m.list)
  }
  #Running model 1 against model 2 to establish effect of exposure
  m1 <- paste0("lmer(", noquote(x),  " ~ Sex + Exposure + DiseaseDiagnosis + AgeAtScreen + (1 | ParticipantNumber), data = i, REML=F)")
  m2 <- paste0("lmer(",  noquote(x),  " ~ Sex  + DiseaseDiagnosis + AgeAtScreen + (1 | ParticipantNumber), data = i, REML=F)")
  (mdls <- c(m1, m2))
  m.list = f_lmer_mc(meta_mvals_Tissue1_clean, mdls, 1)#Calling  parallelization function to run the list of models (mdls) on 1 core - preferably 2 for faster results; number of cores can be equal to number of models
  result_Tissue1_1_2 <- do.call(anova, m.list) #Running ANOVA on models 1 and 2
  results_all_Tissue1_1_2 <- as.data.frame(do.call(rbind, result_Tissue1_1_2)) #rbind ANOVA results for models from each cpg being looped through
  put(results_all_Tissue1_1_2) #put() is almost similar to the return() or print() functions but further helps to store magicalized values 
}
final_results_Tissue1_1_2 <- magic_result_as_dataframe() #Extracting magicalized/ stored results from loop
magic_free() #Clearing stored results to avoid interference with next run
```

#### Tissue1:- Running Model 1 against Model 3 to establish effect of DiseaseDiagnosis
```{r, eval=FALSE}
#Running lme4 and ANOVA on Model 1 & 3
magic_for(silent = TRUE) #Using magic-for to keep loop results in memory
result_Tissue1_1_3 <- data.frame() #Creating empty object to hold ANOVA results in loop

for(x in cpg_list_Tissue1){
  #Function below allows for parallel estimation of multiple models
  f_lmer_mc = function(data, calls, mc.cores) {
    require(parallel)
    if (is.data.frame(data)) 
      data = replicate(length(calls), data, simplify = F)
    for (i in 1:length(data)) attr(data[[i]], "cll") = calls[i]
    m.list = mclapply(data, function(i) eval(parse(text = attr(i, "cll"))), 
                      mc.cores = mc.cores)
    return(m.list)
  }
  #Running modle 1 against model 3 to establish effect of DiseaseDiagnosis
  m1 <- paste0("lmer(", noquote(x),  " ~ Sex + Exposure + DiseaseDiagnosis + AgeAtScreen + (1 | ParticipantNumber), data = i, REML=F)")
  m3 <- paste0("lmer(", noquote(x), " ~ Sex + Exposure + AgeAtScreen + (1 | ParticipantNumber), data = i, REML=F)")
  (mdls <- c(m1, m3))
  m.list = f_lmer_mc(meta_mvals_Tissue1_clean, mdls, 1) #Calling  parallelization function to run the list of models (mdls) on 1 core - preferably 2 for faster results; number of cores can be equal to number of models
  result_Tissue1_1_3 <- do.call(anova, m.list) #Running ANOVA on models 1 & 3
  results_all_Tissue1_1_3 <- as.data.frame(do.call(rbind, result_Tissue1_1_3)) #rbind ANOVA results for models from each cpg being looped through
  put(results_all_Tissue1_1_3) #put() is almost similar to the return() or print() functions but further helps to store magicalized values 
}
final_result_Tissue1_1_3 <- magic_result_as_dataframe() #Extracting magicalized/ stored results from loop
magic_free() #Clearing stored results to avoid interference with next run

#Storing results from ANOVA call for models 1-2 and 1-3
save(final_results_Tissue1_1_2, file="rasiimwe/File_Share/Analysis/LMM19/sites_Cohort/Tissue1/final_results_Tissue1_1_2_call3.RData")
save(final_result_Tissue1_1_3, file="rasiimwe/File_Share/Analysis/LMM19/sites_Cohort/Tissue1/final_result_Tissue1_1_3_call3.RData")
```

#### Tissue1:- extracting *p-values* from the ANOVA summary tables and converting *p* to *q-values* (Model 1 & 2 - establishing effect of exposure)
```{r}
#Loading results from the anavo call on model 1 and 2 
load("rasiimwe/File_Share/Analysis/LMM19/sites_Cohort/Tissue1/final_results_Tissue1_1_2_call3.RData")
head(final_results_Tissue1_1_2, n = 5)

#Unnesting dataframe
final_results_unnested_Tissue1_m1_2 <- as.data.frame(unnest(final_results_Tissue1_1_2, cols = c(results_all_Tissue1_1_2)))
colnames(final_results_unnested_Tissue1_m1_2) <- c("CpG", "model2", "model1") #The p-value from running ANOVA on model 1 and 2 is stored in the model1 variable 
head(final_results_unnested_Tissue1_m1_2, n = 5)

#Extracting p-values from models 1 and 2 
final_results_unnested_Tissue1_sig_m1_2 <- final_results_unnested_Tissue1_m1_2[seq(8, nrow(final_results_unnested_Tissue1_m1_2), 8), ] #p-values are at every 8th row, extracting only p-values
final_results_unnested_Tissue1_sig_m1_2$model2 <- NULL
colnames(final_results_unnested_Tissue1_sig_m1_2) <- c("CpG", "P_Value") 

final_results_unnested_Tissue1_sig_m1_2 %>% head(n = 10) %>% 
  kable(caption = "Tissue1-Exposure: Dataset with p-values from model1 - model2 comparisons (ANOVA)") %>% 
  kable_styling(c("striped", "bordered"),
                full_width = FALSE) 

#Table of p-values < 0.01
pvalue_0.01 <- final_results_unnested_Tissue1_sig_m1_2 %>% 
  filter(final_results_unnested_Tissue1_sig_m1_2$P_Value < 0.01)
pvalue_0.01 <- inner_join(pvalue_0.01, gene_name_mapping, by = "CpG")
colnames(pvalue_0.01) <- c("CpG", "P_Value_0.01", "Gene") 

nrow(pvalue_0.01)

pvalue_0.01 %>% head(n = 10) %>% 
  kable(caption = "9 CpGs in total with p-value < 0.01 (Tissue1-Exposure)") %>% 
  kable_styling(c("striped", "bordered"),
                full_width = FALSE) 

#Converting p to q-values 
#Test run on all p.adjust.methods to see which performs best in converting our p to q values
p_values <- final_results_unnested_Tissue1_sig_m1_2$P_Value

p.adjust.M <- p.adjust.methods[p.adjust.methods != "BH"]
p.adj    <- sapply(p.adjust.M, function(meth) p.adjust(p_values, meth))
stopifnot(identical(p.adj[,"none"], p_values), p.adj <= p.adj)
Tissue1_exposure_fdr <- as.data.frame(round(p.adj, 3))

#Table of q-values from all methods
Tissue1_exposure_fdr %>% head(n = 10) %>% 
  kable(caption = "Table of q-values from all p.adjust.methods (Tissue1-Exposure)") %>% 
  kable_styling(c("striped", "bordered"),
                full_width = FALSE) 

#Extracting minimum q-value from each model 
min(Tissue1_exposure_fdr$holm)
min(Tissue1_exposure_fdr$hochberg)
min(Tissue1_exposure_fdr$hommel)
min(Tissue1_exposure_fdr$bonferroni)
min(Tissue1_exposure_fdr$BY)
min(Tissue1_exposure_fdr$fdr)
#As seen above, apart from "BY" we have all methods reporting a min q-value of 0.011

##plot
#matplot(p_values, p.adj, ylab="p.adjust(data, meth)", type = "l", asp = 1, lty = 1:6,
# main = "P-value adjustments")
#legend(0.7, 0.6, p.adjust.M, col = 1:6, lty = 1:6)

#Converting p-values to q-values
final_results_unnested_Tissue1_sig_m1_2$Q_Value_0.10 <-  round(p.adjust(final_results_unnested_Tissue1_sig_m1_2$P_Value, "fdr"), 2)
dim(Tissue1_exposure <- final_results_unnested_Tissue1_sig_m1_2 %>% 
      filter(Q_Value_0.10 <= 0.10)) #0 CpGs meeting FDR <= 0.10

#Candidates meeting FDR < 0.10 in Tissue1 - Exposure (cg26413528, cg10411339, cg05125843)
Tissue1_exposure <- inner_join(Tissue1_exposure, gene_name_mapping, by = "CpG")
Tissue1_exposure %>% 
  kable(caption = "Candidates meeting FDR <= 0.10 in Tissue1 (Effect of Exposure): (n = 0)") %>% 
  kable_styling(c("striped", "bordered"),
                full_width = FALSE) 
```


#### Tissue1:- extracting *p-values* from the ANOVA summary tables and converting *p* to *q-values* (Model 1 & 3 - establishing effect of DiseaseDiagnosis)
```{r}
#Loading results from the anavo call on model 1 and 3 
load("rasiimwe/File_Share/Analysis/LMM19/sites_Cohort/Tissue1/final_result_Tissue1_1_3_call3.RData")
head(final_result_Tissue1_1_3, n = 5)

#Unnesting dataframe
final_results_unnested_Tissue1_m1_3 <- as.data.frame(unnest(final_result_Tissue1_1_3, cols = c(results_all_Tissue1_1_3)))
colnames(final_results_unnested_Tissue1_m1_3) <- c("CpG", "model2", "model1") #The p-value from running ANOVA on model 1 and 3 is stored in the model1 variable 
head(final_results_unnested_Tissue1_m1_3, n = 5)

#Extracting p-values from models 1 and 3
final_results_unnested_Tissue1_sig_m1_3 <- final_results_unnested_Tissue1_m1_3[seq(8, nrow(final_results_unnested_Tissue1_m1_3), 8), ] #pvalues are at every 8th row, extracting only pvalues
final_results_unnested_Tissue1_sig_m1_3$model2 <- NULL
colnames(final_results_unnested_Tissue1_sig_m1_3) <- c("CpG", "P_Value")

final_results_unnested_Tissue1_sig_m1_3 %>% 
  head(n = 10) %>%   
  kable(caption = "Tissue1-DiseaseDiagnosis: Dataset with p-values from model1 - model3 comparisons (ANOVA)") %>% 
  kable_styling(c("striped", "bordered"),
                full_width = FALSE) 

#Table of p-values < 0.01
pvalue_0.01 <- final_results_unnested_Tissue1_sig_m1_3 %>% 
  filter(final_results_unnested_Tissue1_sig_m1_3$P_Value < 0.01)
pvalue_0.01 <- inner_join(pvalue_0.01, gene_name_mapping, by = "CpG")

nrow(pvalue_0.01)

pvalue_0.01 %>% head(n = 10) %>% 
  kable(caption = "5 CpGs in total with p-value < 0.01 (Tissue1-DiseaseDiagnosis)") %>% 
  kable_styling(c("striped", "bordered"),
                full_width = FALSE) 

#Converting p to q-values 
#Test run on all p.adjust.methods to see which performs best converting our p to q values 
p_values <- final_results_unnested_Tissue1_sig_m1_3$P_Value
p.adjust.M <- p.adjust.methods[p.adjust.methods != "BH"]
p.adj    <- sapply(p.adjust.M, function(meth) p.adjust(p_values, meth))
stopifnot(identical(p.adj[,"none"], p_values), p.adj <= p.adj)
Tissue1_Disease_fdr <- as.data.frame(round(p.adj, 3))

#Table of q-values from all methods
Tissue1_Disease_fdr %>% 
  head(n = 10) %>% 
  kable(caption = "Table of q-values from all p.adjust.methods (Tissue1-DiseaseDiagnosis)") %>% 
  kable_styling(c("striped", "bordered"),
                full_width = FALSE) 

#Extracting minimum q-value from each model 
min(Tissue1_Disease_fdr$holm)
min(Tissue1_Disease_fdr$hochberg)
min(Tissue1_Disease_fdr$hommel)
min(Tissue1_Disease_fdr$bonferroni)
min(Tissue1_Disease_fdr$BY)
min(Tissue1_Disease_fdr$fdr)
#As seen above, none of the p.adjust.methods gives us q-values <= 0.10

#Converting p-values to q-values
final_results_unnested_Tissue1_sig_m1_3$Q_Value_0.10 <-  round(p.adjust(final_results_unnested_Tissue1_sig_m1_3$P_Value, "fdr"), 2)
dim(Tissue1_Disease <- final_results_unnested_Tissue1_sig_m1_3 %>% 
      filter(Q_Value_0.10 <= 0.10)) #No CpGs meeting FDR <= 0.10

#Candidates meeting FDR < 0.10 in Tissue1 - Asthama
Tissue1_Disease <- inner_join(Tissue1_Disease, gene_name_mapping, by = "CpG")
Tissue1_Disease %>% 
  kable(caption = "Candidates meeting FDR <= 0.10 in Tissue1 (Effect of DiseaseDiagnosis): (n = 0)") %>% 
  kable_styling(c("striped", "bordered"),
                full_width = FALSE) 
```


### Tissue2 LMMs
#### Tissue2:- Running Model 1 against Model 2 to establish effect of Exposure
```{r, eval=FALSE}
#Loading Tissue2 M-Values and candidates found in Tissue3
load("rasiimwe/File_Share/Analysis/LMM19/sites_Cohort/Tissue2/meta_mvals_Tissue2_clean.RData")
load("rasiimwe/File_Share/Analysis/LMM19/sites_Cohort/Tissue2/cpg_list_Tissue2.RData")

#Running lme4 and ANOVA on Model 1 & 2 - effect of exposure
magic_for(silent = TRUE) #Using magic-for to keep loop results in memory
result_Tissue2_1_2 <- data.frame() #Creating empty object to hold ANOVA results in loop

for(x in cpg_list_Tissue2){
  #Function below allows for parallel estimation of multiple models
  f_lmer_mc = function(data, calls, mc.cores) {
    require(parallel)
    if (is.data.frame(data)) 
      data = replicate(length(calls), data, simplify = F)
    for (i in 1:length(data)) attr(data[[i]], "cll") = calls[i]
    m.list = mclapply(data, function(i) eval(parse(text = attr(i, "cll"))), 
                      mc.cores = mc.cores)
    return(m.list)
  }
  #Running model 1 against model 2 to establish effect of exposure
  m1 <- paste0("lmer(", noquote(x),  " ~ Sex + Exposure + DiseaseDiagnosis + AgeAtScreen + (1 | ParticipantNumber), data = i, REML=F)")
  m2 <- paste0("lmer(",  noquote(x),  " ~ Sex  + DiseaseDiagnosis + AgeAtScreen + (1 | ParticipantNumber), data = i, REML=F)")
  (mdls <- c(m1, m2))
  m.list = f_lmer_mc(meta_mvals_Tissue2_clean, mdls, 1) #Calling  parallelization function to run the list of models (mdls) on 1 core - preferably 2 for faster results; number of cores can be equal to number of models
  result_Tissue2_1_2 <- do.call(anova, m.list) #Running ANOVA on models 1 and 2
  results_all_Tissue2_1_2 <- as.data.frame(do.call(rbind, result_Tissue2_1_2)) #rbind ANOVA results for models from each cpg being looped through
  put(results_all_Tissue2_1_2) #put() is almost similar to the return() or print() functions but further helps to store magicalized values 
}
final_results_Tissue2_1_2 <- magic_result_as_dataframe() #Extracting magicalized/ stored results from loop
magic_free() #Clearing stored results to avoid interference with next run
```

#### Tissue2:- Running Model 1 against Model 3 to establish effect of DiseaseDiagnosis
```{r, eval=FALSE}
#Running lme4 and ANOVA on Model 1 & 3
magic_for(silent = TRUE) #Using magic-for to keep loop results in memory
result_Tissue2_1_3 <- data.frame() #Creating empty object to hold ANOVA results in loop

for(x in cpg_list_Tissue2){
  #Function below allows for parallel estimation of multiple models
  f_lmer_mc = function(data, calls, mc.cores) {
    require(parallel)
    if (is.data.frame(data)) 
      data = replicate(length(calls), data, simplify = F)
    for (i in 1:length(data)) attr(data[[i]], "cll") = calls[i]
    m.list = mclapply(data, function(i) eval(parse(text = attr(i, "cll"))), 
                      mc.cores = mc.cores)
    return(m.list)
  }
  #Running modle 1 against model 3 to establish effect of DiseaseDiagnosis
  m1 <- paste0("lmer(", noquote(x),  " ~ Sex + Exposure + DiseaseDiagnosis + AgeAtScreen + (1 | ParticipantNumber), data = i, REML=F)")
  m3 <- paste0("lmer(", noquote(x), " ~ Sex + Exposure + AgeAtScreen + (1 | ParticipantNumber), data = i, REML=F)")
  (mdls <- c(m1, m3))
  m.list = f_lmer_mc(meta_mvals_Tissue2_clean, mdls, 1) #Calling  parallelization function to run the list of models (mdls) on 1 core - preferably 2 for faster results; number of cores can be equal to number of models
  result_Tissue2_1_3 <- do.call(anova, m.list) #Running ANOVA on models 1 & 3
  results_all_Tissue2_1_3 <- as.data.frame(do.call(rbind, result_Tissue2_1_3)) #rbind ANOVA results for models from each cpg being looped through
  put(results_all_Tissue2_1_3) #put() is almost similar to the return() or print() functions but further helps to store magicalized values#put() is almost similar to the return() or print() functions but further helps to store magicalized values
}
final_result_Tissue2_1_3 <- magic_result_as_dataframe() #Extracting magicalized/ stored results from loop
magic_free() #Clearing stored results to avoid interference with next run

#Storing results from ANOVA call for models 1-2 and 1-3
save(final_results_Tissue2_1_2, file="rasiimwe/File_Share/Analysis/LMM19/sites_Cohort/Tissue2/final_results_Tissue2_1_2_call3.RData")
save(final_result_Tissue2_1_3, file="rasiimwe/File_Share/Analysis/LMM19/sites_Cohort/Tissue2/final_result_Tissue2_1_3_call3.RData")
```

#### Tissue2:- extracting *p-values* from the ANOVA summary tables and converting *p* to *q-values* (Model 1 & 2 - establishing effect of exposure)
```{r}
#Loading results from the anavo call on model 1 and 2 
load("rasiimwe/File_Share/Analysis/LMM19/sites_Cohort/Tissue2/final_results_Tissue2_1_2_call3.RData")
head(final_results_Tissue2_1_2, n = 5)

#Unnesting dataframe
final_results_unnested_Tissue2_m1_2 <- as.data.frame(unnest(final_results_Tissue2_1_2, cols = c(results_all_Tissue2_1_2)))
colnames(final_results_unnested_Tissue2_m1_2) <- c("CpG", "model2", "model1") #The p-value from running ANOVA on model 1 and 2 is stored in the model1 variable 
head(final_results_unnested_Tissue2_m1_2, n = 5)

#Extracting p-values from models 1 and 2 
final_results_unnested_Tissue2_sig_m1_2 <- final_results_unnested_Tissue2_m1_2[seq(8, nrow(final_results_unnested_Tissue2_m1_2), 8), ] #p-values are at every 8th row, extracting only pvalues
final_results_unnested_Tissue2_sig_m1_2$model2 <- NULL
colnames(final_results_unnested_Tissue2_sig_m1_2) <- c("CpG", "P_Value") 

final_results_unnested_Tissue2_sig_m1_2 %>% head(n = 10) %>%  
  kable(caption = "Tissue2-Exposure: Dataset with p-values from model1 - model2 comparisons (ANOVA)") %>% 
  kable_styling(c("striped", "bordered"),
                full_width = FALSE) 

#Table of p-values < 0.01
pvalue_0.01 <- final_results_unnested_Tissue2_sig_m1_2 %>% 
  filter(final_results_unnested_Tissue2_sig_m1_2$P_Value < 0.01)
pvalue_0.01 <- inner_join(pvalue_0.01, gene_name_mapping, by = "CpG")

nrow(pvalue_0.01)

pvalue_0.01 %>% 
  head(n = 10) %>% 
  kable(caption = "4 CpGs in total with p-value < 0.01 (Tissue2-Exposure)") %>% 
  kable_styling(c("striped", "bordered"),
                full_width = FALSE) 

#Converting p to q-values 
#Test run on all p.adjust.methods to see which performs best converting our p to q values
p_values <- final_results_unnested_Tissue2_sig_m1_2$P_Value

p.adjust.M <- p.adjust.methods[p.adjust.methods != "BH"]
p.adj    <- sapply(p.adjust.M, function(meth) p.adjust(p_values, meth))
stopifnot(identical(p.adj[,"none"], p_values), p.adj <= p.adj)
Tissue2_exposure_fdr <- as.data.frame(round(p.adj, 3))

#Table of q-values from all methods
Tissue2_exposure_fdr %>% 
  head(n = 10) %>% 
  kable(caption = "Table of q-values from all p.adjust.methods (Tissue2-Exposure)") %>% 
  kable_styling(c("striped", "bordered"),
                full_width = FALSE) 

#Extracting minimum q-value from each model 
min(Tissue2_exposure_fdr$holm)
min(Tissue2_exposure_fdr$hochberg)
min(Tissue2_exposure_fdr$hommel)
min(Tissue2_exposure_fdr$bonferroni)
min(Tissue2_exposure_fdr$BY)
min(Tissue2_exposure_fdr$fdr)
#As seen above, none of the p.adjust.methods gives us q-values <= 0.10

#Converting p-values to q-values
final_results_unnested_Tissue2_sig_m1_2$Q_Value_0.10 <-  round(p.adjust(final_results_unnested_Tissue2_sig_m1_2$P_Value, "fdr"), 2)
dim(Tissue2_exposure <- final_results_unnested_Tissue2_sig_m1_2 %>% 
      filter(Q_Value_0.10 <= 0.10)) #No CpGs meeting FDR <= 0.10

#Candidates meeting FDR < 0.10 in Tissue2 - Exposure (cg25217365, cg18671950)
Tissue2_exposure <- inner_join(Tissue2_exposure, gene_name_mapping, by = "CpG")
Tissue2_exposure %>% 
  kable(caption = "Candidates meeting FDR <= 0.10 in Tissue2 (Effect of Exposure): (n = 0)") %>% 
  kable_styling(c("striped", "bordered"),
                full_width = FALSE) 
##write.csv(Tissue2_exposure, file="~/rebecca.asiimwe/sites_Cohort/Tissue2/Tissue2_exposurem12_call2.csv")
```

#### Tissue2:- extracting *p-values* from the ANOVA summary tables and converting *p* to *q-values* (Model 1 & 3 - establishing effect of DiseaseDiagnosis)
```{r}
#Loading results from the anavo call on model 1 and 3 
load("rasiimwe/File_Share/Analysis/LMM19/sites_Cohort/Tissue2/final_result_Tissue2_1_3_call3.RData")
head(final_result_Tissue2_1_3, n = 5)

#Unnesting dataframe
final_results_unnested_Tissue21_3 <- as.data.frame(unnest(final_result_Tissue2_1_3, cols = c(results_all_Tissue2_1_3)))
colnames(final_results_unnested_Tissue21_3) <- c("CpG", "model2", "model1") #The p-value from running ANOVA on model 1 and 2 is stored in the model1 variable 
head(final_results_unnested_Tissue21_3, n = 5)

#Extracting p-values from models 1 and 3
final_results_unnested_Tissue2_sig_m1_3 <- final_results_unnested_Tissue21_3[seq(8, nrow(final_results_unnested_Tissue21_3), 8), ] #pvalues are at every 8th row, extracting only pvalues 
final_results_unnested_Tissue2_sig_m1_3$model2 <- NULL
colnames(final_results_unnested_Tissue2_sig_m1_3) <- c("CpG", "P_Value")

final_results_unnested_Tissue2_sig_m1_3 %>% 
  head(n = 10) %>% 
  kable(caption = "Dataset with p-values from model1 - model3 comparisons (ANOVA)") %>% 
  kable_styling(c("striped", "bordered"),
                full_width = FALSE) 

#Table of p-values < 0.01
pvalue_0.01 <- final_results_unnested_Tissue2_sig_m1_3 %>% 
  filter(final_results_unnested_Tissue2_sig_m1_3$P_Value < 0.01)
pvalue_0.01 <- inner_join(pvalue_0.01, gene_name_mapping, by = "CpG")
colnames(pvalue_0.01) <- c("CpG", "P_Value_0.01", "Gene") 

nrow(pvalue_0.01)

pvalue_0.01 %>% 
  head(n = 10) %>% 
  kable(caption = "3 CpGs in total with p-value < 0.01 (Tissue2-DiseaseDiagnosis)") %>% 
  kable_styling(c("striped", "bordered"),
                full_width = FALSE) 

#Converting p to q-values 
#Test run on all p.adjust.methods to see which performs best converting our p to q values
p_values <- final_results_unnested_Tissue2_sig_m1_3$P_Value

p.adjust.M <- p.adjust.methods[p.adjust.methods != "BH"]
p.adj    <- sapply(p.adjust.M, function(meth) p.adjust(p_values, meth))
stopifnot(identical(p.adj[,"none"], p_values), p.adj <= p.adj)
Tissue2_Disease_fdr <- as.data.frame(round(p.adj, 3))

#Table of q-values from all methods
Tissue2_Disease_fdr %>% 
  head(n = 10) %>% 
  kable(caption = "Table of q-values from all p.adjust.methods (Tissue2-DiseaseDiagnosis)") %>% 
  kable_styling(c("striped", "bordered"),
                full_width = FALSE) 

#Extracting minimum q-value from each model 
min(Tissue2_Disease_fdr$holm)
min(Tissue2_Disease_fdr$hochberg)
min(Tissue2_Disease_fdr$hommel)
min(Tissue2_Disease_fdr$bonferroni)
min(Tissue2_Disease_fdr$BY)
min(Tissue2_Disease_fdr$fdr)
#As seen above, none of the p.adjust.methods gives us q-values <= 0.10

#Converting p-values to q-values
final_results_unnested_Tissue2_sig_m1_3$Q_Value_0.10 <-  round(p.adjust(final_results_unnested_Tissue2_sig_m1_3$P_Value, "fdr"), 2)
dim(Tissue2_Disease <- final_results_unnested_Tissue2_sig_m1_3 %>% 
      filter(Q_Value_0.10 <= 0.10)) #No CpGs meeting FDR <= 0.10

#Candidates meeting FDR < 0.10 in Tissue2 - Asthama
Tissue2_Disease <- inner_join(Tissue2_Disease, gene_name_mapping, by = "CpG")
Tissue2_Disease %>% 
  kable(caption = "Candidates meeting FDR <= 0.10 in Tissue2 (Effect of DiseaseDiagnosis): (n = 0)") %>% 
  kable_styling(c("striped", "bordered"),
                full_width = FALSE) 
```


### Running Tukey's test on Exposure models for significant CpG sites (FDR <= 0.10)
#### Tissue1 Tukey Exposure results
```{r, eval=FALSE}
load("~/rebecca.asiimwe/sites_Cohort/Tissue1/meta_mvals_Tissue1_clean.RData")
cpg_list_Tissue1_sig <- Tissue1_exposure$CpG

#Running Tukey's test on Model 1 and 2 that tests exposure effect
magic_for(silent = TRUE) #stores all loop results 
result_Tissue1_1_2_sig <- data.frame() #Creating empty object to hold ANOVA results in loop

for(x in cpg_list_Tissue1_sig){
  #Running linear mixed model fit by maximum likelihood on Model 1 Vs 2 to test exposure effect
  modl <- as.formula(paste0("lmer(", noquote(x),  " ~ Sex + Exposure + DiseaseDiagnosis + AgeAtScreen + (1 | ParticipantNumber),  meta_mvals_Tissue1_clean, REML=F)"))
  model <- eval(bquote(lmer(.(modl), data=meta_mvals_Tissue1_clean, REML=F))) #Captures results from linear mixed model
  result_Tissue1_1_2_sig <- summary(glht(model, linfct=mcp(Exposure="Tukey"))) #Using glht with Tukey's significance test to conduct multiple exposure comparisons and pass summary results to result_Tissue1_1_2_sig object
  results_all_Tissue1_1_2_sig <- as.data.frame(do.call(rbind, result_Tissue1_1_2_sig[10])) #Interested in list element 10 that contains linear hypothesis results
  put(results_all_Tissue1_1_2_sig)
}
final_results_all_Tissue1_1_2_sig <- magic_result_as_dataframe() #Extracting magicalized/ stored results from loop
magic_free() #Clearing stored results to avoid interference with next run

#Unnesting results from loop
final_results_unnested_Tissue1_m1_2_sig <- as.data.frame(unnest(final_results_all_Tissue1_1_2_sig, cols = c(results_all_Tissue1_1_2_sig)))
final_results_unnested_Tissue1_m1_2_sig$pfunction <- NULL
final_results_unnested_Tissue1_m1_2_sig$qfunction <- NULL
final_results_unnested_Tissue1_m1_2_sig$type <- NULL

#Extracting Estimate/Coefficients
coefficients_Tissue1_exp <- as.data.frame(final_results_unnested_Tissue1_m1_2_sig$coefficients)
colnames(coefficients_Tissue1_exp) <- final_results_unnested_Tissue1_m1_2_sig$x
colnames(coefficients_Tissue1_exp) <- paste0(colnames(coefficients_Tissue1_exp), "_", "Estimate")

#Extracting Std.Error
sigma_Tissue1_exp <- as.data.frame(final_results_unnested_Tissue1_m1_2_sig$sigma)
colnames(sigma_Tissue1_exp) <- final_results_unnested_Tissue1_m1_2_sig$x
colnames(sigma_Tissue1_exp) <- paste0(colnames(sigma_Tissue1_exp), "_", "Std.Error")

#Extracting Z_Value
tstat_Tissue1_exp <- as.data.frame(final_results_unnested_Tissue1_m1_2_sig$tstat)
colnames(tstat_Tissue1_exp) <- final_results_unnested_Tissue1_m1_2_sig$x
colnames(tstat_Tissue1_exp) <- paste0(colnames(tstat_Tissue1_exp), "_", "Z_Value")

#Extracting P_Value
pvalues_Tissue1_exp <- as.data.frame(final_results_unnested_Tissue1_m1_2_sig$pvalues)
colnames(pvalues_Tissue1_exp) <- final_results_unnested_Tissue1_m1_2_sig$x
colnames(pvalues_Tissue1_exp) <- paste0(colnames(pvalues_Tissue1_exp), "_", "P_Value")

#Combining results 
Linear_Hypotheses_Tissue1_exp <- cbind(coefficients_Tissue1_exp, sigma_Tissue1_exp, tstat_Tissue1_exp, pvalues_Tissue1_exp)
Linear_Hypotheses_Tissue1_exp <- Linear_Hypotheses_Tissue1_exp[,order(colnames(Linear_Hypotheses_Tissue1_exp))]
Linear_Hypotheses_Tissue1_exp <- round(Linear_Hypotheses_Tissue1_exp, 5)
Linear_Hypotheses_Tissue1_exp_pvalues <- Linear_Hypotheses_Tissue1_exp[,grep("P_Value", colnames(Linear_Hypotheses_Tissue1_exp))]
Linear_Hypotheses_Tissue1_exp_pvalues

#Converting p-values to q-values for each cpg and exposure comparison
Linear_Hypotheses_Tissue1_exp_pvalues$Exposure <- rownames(Linear_Hypotheses_Tissue1_exp_pvalues)
pvalues <- melt(Linear_Hypotheses_Tissue1_exp_pvalues, "Exposure")
pvalues$q_values <- round(p.adjust(pvalues$value, "fdr"), 2)
colnames(pvalues)[2:3] <- c("CpG", "p-values")
pvalues$CpG <- sub("_P_Value", "", pvalues$CpG)
pvalues
```

#### Box plots for significant sites - Tissue1 Exposure
```{r, eval=FALSE}
load("~/rebecca.asiimwe/sites_Cohort/Tissue1/betas_Tissue1.RData")
dim(betas_Tissue1_filt <- betas_Tissue1[which(rownames(betas_Tissue1) %in% Tissue1_exposure$CpG),])

#loading Tissue1 metadata and matching it with beta file
meta_Tissue1_clean <-  as.data.frame(read_excel("~/rebecca.asiimwe/File_Share/Data/Cohort_meta_clean/meta_Tissue1.xls"))
rownames(meta_Tissue1_clean) <- meta_Tissue1_clean$SampleID_meta
meta_Tissue1_clean$SampleID_meta<- NULL
identical(colnames(betas_Tissue1), rownames(meta_Tissue1_clean))
meta_Tissue1_clean <- meta_Tissue1_clean[match(colnames(betas_Tissue1), rownames(meta_Tissue1_clean)),]
identical(colnames(betas_Tissue1), rownames(meta_Tissue1_clean))

betas_Tissue1_filt_transposed <- t(betas_Tissue1_filt)
identical(rownames(betas_Tissue1_filt_transposed), rownames(meta_Tissue1_clean))
meta_betas_Tissue1 <- merge(meta_Tissue1_clean, betas_Tissue1_filt_transposed, by = "row.names")
colnames(meta_betas_Tissue1)[1] <- "SampleID_meta"

meta_betas_Tissue1 <- meta_betas_Tissue1[,c(1, 9,11,12,27:29)]
meta_betas_Tissue1_melt <- melt(meta_betas_Tissue1, id.vars = c("SampleID_meta", "Sex", "Exposure", "ExposureOrder"))
colnames(meta_betas_Tissue1_melt)[c(5,6)] <- c("CpG", "Beta_Value")

unique(meta_betas_Tissue1_melt$Exposure) 
meta_betas_Tissue1_melt$Exposure  <- factor(meta_betas_Tissue1_melt$Exposure , levels = c("Exp3", "Exp2", "Exp1", "Exp4"))
levels(meta_betas_Tissue1_melt$Exposure)

#cg05125843
(p1 <- meta_betas_Tissue1_melt %>% filter(CpG=="cg1") %>% 
    ggplot(aes(Exposure, Beta_Value, fill = Exposure)) + 
    geom_boxplot(alpha = 0.3) +
    scale_fill_brewer(palette = "PuBu") + 
    scale_color_brewer(palette = "PuBu") +
    labs(y="Betas", x="") +
    theme_bw() + ggtitle("cg1-Tissue1") +
    theme(plot.title = element_text(hjust = 0.5))) #+ theme(legend.position = "none"))

#cg10411339
(p3 <- meta_betas_Tissue1_melt %>% filter(CpG=="cg2") %>% 
    ggplot(aes(Exposure, Beta_Value, fill = Exposure)) + 
    geom_boxplot(alpha = 0.3) +
    scale_fill_brewer(palette = "PuBu") + 
    scale_color_brewer(palette = "PuBu") +
    labs(y="Betas", x="") +
    theme_bw() + ggtitle("cg2-Tissue1") +
    theme(plot.title = element_text(hjust = 0.5)))

#cg26413528
(p6 <- meta_betas_Tissue1_melt %>% filter(CpG=="cg3") %>% 
    ggplot(aes(Exposure, Beta_Value, fill = Exposure)) + 
    geom_boxplot(alpha = 0.3) +
    scale_fill_brewer(palette = "PuBu") + 
    scale_color_brewer(palette = "PuBu") +
    labs(y="Betas", x="") +
    theme_bw() + ggtitle("cg3-Tissue1") +
    theme(plot.title = element_text(hjust = 0.5)))

#(grid.arrange(p1, p2, p3, nrow = 2, ncol=3))
```


